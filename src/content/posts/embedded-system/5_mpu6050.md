---
title: "[CanSat#5] MPU6050"
published: 2025-12-18
description: 'MEMS 기술 기반의 IMU 센서 원리 이해 및 가속도계를 이용한 오일러 각(Roll, Pitch) 산출 알고리즘 구현'
image: ''
tags: [ESP32, 임베디드시스템, 캔위성]
category: '캔위성 프로젝트'
draft: false 
lang: 'ko'
---

캔위성이 낙하하거나 하늘에서 운동하는 동안 고도는 너무 적은 정보이다. 위성의 `기울어진 각도` 또는 `회전상태` `가속도` 등 **자세정보를** 파악하는게 중요하다. 이를 위해 사용되는 센서는 `IMU`(Inertial Measurement Unit, 관성측정장치)이다. 이번 포스팅에서는 가장 흔하게 쓰이는 `MPU6050` 센서의 동작 원리와 데이터 처리 방법을 다뤄보고자 한다. 아래는 MPU6050 센서의 사진과 각 핀에 대한 설명이다. 여기서는 VCC, GND, SCL, SDA 핀만 다루도록 하겠다.

<div class="w-full mx-auto flex justify-center">

![이미지](https://components101.com/sites/default/files/components/MPU6050-Module.jpg)

![이미지](https://components101.com/sites/default/files/component_pin/MPU6050-Pinout.png)
</div>

---

# 1. MPU6050 개요
MPU6050은 MEMS(Micro-Electro-Mechanical Systems) 기술을 기반으로 제작되었습니다. 칩 내부에는 눈에 보이지 않을 정도로 작은 미세 기계 구조물이 들어있어 물리적인 움직임을 전기적 신호로 변환합니다. 아래는 MPU6050에 있는 가속도계의 물리적 작동원리에 대해 설명한 영상입니다.

<iframe width="100%" height="468" src="https://www.youtube.com/embed/KuekQ-m9xpw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## 1-1. 3축 가속도계
가속도계의 측정범위의 g는 중력가속도 $1g = 9.8m/s^2$를 의미한다. 측정된 RawData(원시측정값)을 감도계수로 나눠 각 x,y,z축에 작용하는 관성 가속도를 구할 수 있습니다.

$$
Acceleration (g) = \frac{RawData}{LSB/g}
$$

|측정 범위| 감도 계수(LSB/g) |해상도(mg/LSB)|비고|
|:---|:---|:---|:---|
|±2g|16384|0.061|가장 정밀한 측정 가능 |
|±4g|8192|0.122|중간 정밀도 |
|±8g|4096|0.244|일반적인 드론/위성 권장 |
|±16g|2048|0.488|큰 충격이 발생하는 환경 |

<div class="w-full mx-auto flex justify-center">

![3축가속도계](https://lastminuteengineers.com/wp-content/uploads/arduino/MPU6050-Module-Accelerometer-Axis.jpg)
[사진 출처] (https://lastminuteengineers.com)
</div>

## 1-2. 3축 자이로센서

|측정 범위| 감도 계수(LSB/deg/s) |해상도(deg/s/LSB)|비고|
|:---|:---|:---|:---|
|±250deg/s|131|0.0076|정적인 자세 제어 |
|±500deg/s|65.5|0.0152|일반적인 회전 측정 |
|±1000deg/s|32.8|0.0305|고속 회전 환경 |
|±2000deg/s|16.4|0.061|급격한 기동 환경 |


<div class="w-full mx-auto flex justify-center">

![3축자이로센서](https://lastminuteengineers.com/wp-content/uploads/arduino/MPU6050-Module-Gyroscope-Axis.jpg)
[사진 출처] (https://lastminuteengineers.com)
</div>

:::tip[범위와 정밀도의 상관관계]
MPU6050은 16비트라는 한정된 자원(단계)을 사용합니다. 측정 범위를 좁게 잡을수록($\pm 2g$) 한 단계(1 LSB)가 나타내는 물리량이 작아지므로(0.061mg), 감도 계수가 커지고 정밀도는 높아집니다. 반대로 범위를 넓게 잡으면 더 큰 충격을 측정할 수 있지만, 세밀한 변화를 감지하는 능력은 떨어지게 됩니다.
:::

---

# 2. 물리적 작동 원리: MEMS 기술

## 2-1. 가속도계: 가변 정전용량 방식
가속도계 내부에 미세한 스프링에 매달린 질량체가 존재합니다. 외부 가속도가 가해지면 관성에 의해 질량체가 이동하게 되고, 이때 고정된 `전극과 거리가 변하게` 됩니다. 이때 축전기의 `정전용량(Capacitance)` 변화를 측정하여 가속도를 계산합니다.

<div class="w-full mx-auto flex justify-center">

![이미지](https://lastminuteengineers.com/wp-content/uploads/arduino/MEMS-Accelerometer-Working.gif)
[사진 출처] (https://lastminuteengineers.com)

</div>

## 2-2. 자이로스코프: 코리올리 힘
회전하는 물체 위에서 운동하는 입자는 운동 방향에 수직인 힘을 받는데 이 힘을 `코리올리 힘`이라고 합니다. MEMS 자이로 내부의 미세 구조물이 진동하고 있을 때 외부 회전이 발생하면, 코리올리 힘에 의해 진동축이 변하게 되고 이때 변한 각 질량체 들의 거리변화를 측정하여 각속도를 계산합니다.

아래 그림과 같이 네 개의 부분으로 구성된 `추진 질량체`가 있고 이는 특정 주파수로 진동하고 있습니다. 외부 회전이 발생하면 코리올리 힘에 의해 진동축이 변하게 되고 이때 변한 각 질량체 들의 거리변화를 측정하여 각속도를 계산합니다.

<div class="w-full mx-auto flex justify-center">

![이미지](https://lastminuteengineers.com/wp-content/uploads/arduino/MPU6050-Accel-Gyro-Working-Drive-Mode-Output.gif)
[사진 출처] (https://lastminuteengineers.com)

</div>

다음은 각 방향(롤, 피치, 요)으로 회전이 발생할때 진동축의 변화를 나타낸 그림입니다.

### 롤(roll) 방향 회전

<div class="w-full mx-auto flex justify-center">

![이미지](https://lastminuteengineers.com/wp-content/uploads/arduino/MPU6050-Accel-Gyro-Working-Roll-Mode-Output.gif)
[사진 출처] (https://lastminuteengineers.com)

</div>

### 피치(pitch) 방향 회전

<div class="w-full mx-auto flex justify-center">

![이미지](https://lastminuteengineers.com/wp-content/uploads/arduino/MPU6050-Accel-Gyro-Working-Pitch-Mode-Output.gif)
[사진 출처] (https://lastminuteengineers.com)

</div>

### 요(yaw) 방향 회전
<div class="w-full mx-auto flex justify-center">

![이미지](https://lastminuteengineers.com/wp-content/uploads/arduino/MPU6050-Accel-Gyro-Working-Yaw-Mode-Output.gif)
[사진 출처] (https://lastminuteengineers.com)

</div>

---

# 3. 오일러 각 계산과 한계

물체가 `준정적`으로 움직이거나 `정적인 상태`라면 가속도 센서의 $a_x, a_y, a_z$ 성분만을 이용해 삼각함수로 기울어진 각도를 계산할 수 있습니다. (하지만 이렇게 하면 문제가 생김)

$$
\phi = \arctan2(a_y, a_z), \quad \theta = \arctan2(-a_x, \sqrt{a_y^2 + a_z^2})
$$

## 3-1. 가속도계로만 부족한 이유

가속도계는 `정적인 상태`에서 중력 벡터를 이용해 기울어진 각도를 찾는 것에는 문제가 없지만, 관성에 의한 관성력을 측정해 가속도를 계산하는 센서의 특성상 `동적인 상태`에서는 중력가속도와 관성에 의한 가속도가 같이 작용하기 때문에 정확한 각도를 측정할 수 없습니다.

:::warning[센서 특성 요약]

가속도계(Accelerometer): 저주파 신호에 강함(장기적으로 정확함). 하지만 고주파 노이즈(진동)에 매우 취약함.

자이로스코프(Gyroscope): 고주파 신호에 강함(순간적인 변화에 민감함). 하지만 적분 오차로 인해 시간이 지날수록 값이 흐르는 드리프트(Drift) 현상 발생.
:::


따라서 위와 같은 문제를 해결하기 위해서는 `가속도계`, `자이로스코프`를 같이 상보적으로 이용하는 `상보필터` 또는 `칼만필터`, `매드윅필터` 등의 알고리즘을 사용하여 정확한 각도를 측정할 수 있습니다. 이 내용은 추후에 따로 포스팅 하도록 하겠습니다.

---

# 4. 소프트웨어 구현 및 설정

아래 코드는 가속도계 데이터만을 활용한 기초적인 기울어진 각도 산출 방식입니다. 별도의 필터가 적용되지 않은 코드이므로 동적인 상황에서 정확한 각도를 측정할 수 없습니다!!

```c++
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

Adafruit_MPU6050 mpu;

void setup() {
  Serial.begin(115200);
  if (!mpu.begin()) {
    Serial.println("MPU6050 연결 실패");
    while (1) yield();
  }

  // --- 측정 범위 설정 ---
  // 가속도: ±8g (낙하 충격 대비)
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G); 
  // 자이로: ±500 deg/s (위성 회전 대비)
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);      
  // DLPF(Digital Low Pass Filter) 설정: 21Hz (진동 노이즈 제거)
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);   
}
```

```c++
void loop() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // Raw 데이터 출력 및 오일러 각 계산
  // Adafruit 라이브러리는 내부적으로 LSB 계수를 나누어 m/s^2 단위로 변환해줍니다.
  float roll  = atan2(a.acceleration.y, a.acceleration.z) * 180 / PI;
  float pitch = atan2(-a.acceleration.x, sqrt(pow(a.acceleration.y, 2) + pow(a.acceleration.z, 2))) * 180 / PI;

  Serial.printf("Roll: %.2f | Pitch: %.2f | Temp: %.1f C\n", roll, pitch, temp.temperature);
  delay(100);
}
```